[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "geeknees",
    "section": "",
    "text": "hey ðŸ‘‹"
  },
  {
    "objectID": "posts/2023-07-13introductionGen/index.html",
    "href": "posts/2023-07-13introductionGen/index.html",
    "title": "Introduction to Modeling in Gen",
    "section": "",
    "text": "using Gen\n\n\nusing Plots\n\n\n@gen function line_model(xs::Vector{Float64})\n    # We begin by sampling a slope and intercept for the line.\n    # Before we have seen the data, we don't know the values of\n    # these parameters, so we treat them as random choices. The\n    # distributions they are drawn from represent our prior beliefs\n    # about the parameters: in this case, that neither the slope nor the\n    # intercept will be more than a couple points away from 0.\n    slope = ({:slope} ~ normal(0, 1))\n    intercept = ({:intercept} ~ normal(0, 2))\n\n    # We define a function to compute y for a given x\n    function y(x)\n        return slope * x + intercept\n    end\n\n    # Given the slope and intercept, we can sample y coordinates\n    # for each of the x coordinates in our input vector.\n    for (i, x) in enumerate(xs)\n        # Note that we name each random choice in this loop\n        # slightly differently: the first time through,\n        # the name (:y, 1) will be used, then (:y, 2) for\n        # the second point, and so on.\n        ({(:y, i)} ~ normal(y(x), 0.1))\n    end\n\n    # Most of the time, we don't care about the return\n    # value of a model, only the random choices it makes.\n    # It can sometimems be useful to return something\n    # meaningful, however; here, we return the function `y`.\n    return y\nend;\n\n\nxs = [-5., -4., -3., -2., -1., 0., 1., 2., 3., 4., 5.];\n\n\ny = line_model(xs)\n\ny (generic function with 1 method)\n\n\n\ntrace = Gen.simulate(line_model, (xs,));\n\n\nGen.get_args(trace)\n\n([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],)\n\n\n\nfunction render_trace(trace; show_data=true)\n\n    # Pull out xs from the trace\n    xs, = get_args(trace)\n\n    xmin = minimum(xs)\n    xmax = maximum(xs)\n\n    # Pull out the return value, useful for plotting\n    y = get_retval(trace)\n\n    # Draw the line\n    test_xs = collect(range(-5, stop=5, length=1000))\n    fig = plot(test_xs, map(y, test_xs), color=\"black\", alpha=0.5, label=nothing,\n                xlim=(xmin, xmax), ylim=(xmin, xmax))\n\n    if show_data\n        ys = [trace[(:y, i)] for i=1:length(xs)]\n\n        # Plot the data set\n        scatter!(xs, ys, c=\"black\", label=nothing)\n    end\n\n    return fig\nend;\n\n\nrender_trace(trace)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction grid(renderer::Function, traces)\n    Plots.plot(map(renderer, traces)...)\nend;\n\n\ntraces = [Gen.simulate(line_model, (xs,)) for _=1:12]\ngrid(render_trace, traces)"
  },
  {
    "objectID": "posts/2023-07-15langchainrb/index.html",
    "href": "posts/2023-07-15langchainrb/index.html",
    "title": "langchainrb",
    "section": "",
    "text": "p ENV['RUBYINSPECT']\n\n\"1\"\n\n\n\"1\"\n\n\n\nrequire 'langchain'\n\nopenai = Langchain::LLM::OpenAI.new(api_key: ENV[\"OPENAI_API_KEY\"])\n\nchat = Langchain::Conversation.new(llm: openai)\nchat.set_context(\"You are a chatbot from the future\")\n\nputs \"Welcome to the chatbot from the future!\"\n\nputs chat.message('hey there!')\n\nWelcome to the chatbot from the future!\nHello! How can I assist you today?"
  },
  {
    "objectID": "posts/2023-07-15intorductionRbProb/index.html",
    "href": "posts/2023-07-15intorductionRbProb/index.html",
    "title": "Introduction to rb_prob",
    "section": "",
    "text": "https://github.com/geeknees/rb_prob\n\nrequire 'rubygems'\nrequire 'bundler/setup'\n\nrequire 'prob'\ninclude Probably\n\n# Alarm example from \"Artificial Intelligence - A Modern Approach\" by Russel\n# and Norvig Page 493 cc.\n#\n# Suppose you have a new fairly reliable burglar alarm at home but occasionally\n# it responds to minor earthquakes. You also have two neighbors John and Mary,\n# who have promised to call you at work when they hear the alarm. John always\n# calls when he hears the alarm, but sometimes confuses the telephone ringing\n# with the alarm and calls then, too. Mary, on the other hand, is too much in\n# loud music and sometimes misses the alarm altogether.\n#\n# So the bayesian network will be:\n#\n#           B         E\n#            \\       /\n#            _\\|   |/_\n#                A\n#             /    \\\n#           |/_    _\\|\n#          J          M\n#\n#  with probabilities:\n#  P(B) = 0.001\n#  P(E) = 0.002\n#\n#  P(A| B=true, E=true)   = 0.95\n#  P(A| B=true, E=false)  = 0.94\n#  P(A| B=false, E=true)  = 0.29\n#  P(A| B=false, E=false) = 0.001\n#\n#  P(J| A=true)  = 0.9\n#  P(J| A=false) = 0.05\n#\n#  P(M| A=true)  = 0.7\n#  P(M| A=false) = 0.01\n#\n#  where B = burglar, E = earthquake, A = alarm, J = John calls and\n#  M = Mary calls\n#\n#  ----------------------------------------------------------------------------\n#\n#  Next we want to develop some 'equivalent' functions for querying that\n#  network and do some benchmarks.\n#\n\n# first let's encode the probabilities from the network\n# P(B)\nPBurglary = choose(0.001,  :B, :notB )\n\n# P(E)\nPEarthquake = choose(0.002,  :E, :notE)\n\n# P(A|B = b,E = e)\ndef p_alarm(b, e)\n    pAlarmTable = {\n        [:B, :E] =&gt; 0.95,\n        [:B, :notE] =&gt; 0.94,\n        [:notB, :E] =&gt; 0.29,\n        [:notB, :notE] =&gt; 0.001\n    }\n\n    choose(pAlarmTable[[b, e]],  :A, :notA)\nend\n\n# P(J|A = a)\ndef p_john(a)\n    choose( a == :A ? 0.9 : 0.05, :J, :notJ)\nend\n\n# P(M|A = a)\ndef p_mary(a)\n    choose( a == :A ? 0.7 : 0.01, :M, :notM)\nend\n\n# computes the joint probability and transform result using block (if given)\n# allowing to do some marginalization over one random variable by\n# \"leaving it out\"\n#\n# for example:\n# mk_joint_p {|b,e,a,j,m| [b,e,a]} will find P(b,e,a) = Sum(j,m) { P(b,e,a,j,m) }\n#\ndef mk_joint_p(&blk)\n    PBurglary.dep { |b|\n        PEarthquake.dep {|e|\n            p_alarm(b, e).dep {|a|\n                p_john(a).dep { |j|\n                    p_mary(a).dep {|m|\n                        mk_const(if blk then blk.call([b,e,a,j,m])\n                                else [b,e,a,j,m] end)\n                    }\n                }\n            }\n        }\n    }\nend\n\n# compute (optionally conditional) joint probability of (free) random\n# variables like mk_joint_p.\n#\n# To compute conditional probability set random variables to a known state.\n# for example\n# mk_joint_p2( {:john = :J, :mary = :M} )\n# will compute\n# P(B,E,A| J = true, M = true)\n#\n# or\n# mk_joint_p2({:john = :J, :mary = :M}) {|b,e,a,j,m| b} will find\n# P(B | J = true, M = true)\ndef mk_joint_p2( tsts = {}, &blk )\n    PBurglary.dep { |b|\n    condition(!tsts[:burglary] || tsts[:burglary] == b) {\n        PEarthquake.dep {|e|\n        condition(!tsts[:earthquake] || tsts[:earthquake] == e) {\n            p_alarm(b,e).dep {|a|\n            condition(!tsts[:alarm] || tsts[:alarm] == a) {\n                p_john(a).dep {|j|\n                condition(!tsts[:john] || tsts[:john] == j) {\n                    p_mary(a).dep {|m|\n                    condition(!tsts[:mary] || tsts[:mary] == m) {\n                        mk_const(if blk then blk.call [b,e,a,j,m] else [b,e,a,j,m] end)\n                    }}\n                }}\n            }}\n        }}\n    }}.normalize\nend\n\n# like mk_joint_p2, but using event_dep directly instead of mixing in\n# condition-statements\ndef mk_joint_p3 (tsts = {}, &blk)\n    tst_b = if_just tsts[:burglary]\n    tst_e = if_just tsts[:earthquake]\n    tst_a = if_just tsts[:alarm]\n    tst_j = if_just tsts[:john]\n    tst_m = if_just tsts[:mary]\n\n    PBurglary.event_dep(tst_b) {|b|\n        PEarthquake.event_dep(tst_e) {|e|\n            p_alarm(b,e).event_dep(tst_a) {|a|\n                p_john(a).event_dep(tst_j) {|j|\n                    p_mary(a).event_dep(tst_m) {|m|\n                        mk_const(if blk then blk.call [b,e,a,j,m] else [b,e,a,j,m] end)\n                    }\n                }\n            }\n        }\n    }.normalize\nend\n\n# precompute joint probability to do bayesian inference using filter, map and\n# query?\nPJoint = mk_joint_p\n\nputs 'P(B|M=true, J=true) :'\nputs mk_joint_p3({:mary =&gt; :M, :john =&gt; :J}) {|b,e,a,j,m| b }\n\n# puts \"\\njoint probability:\"\n# puts \"==================\"\n# puts PJoint\n\n# compute P(B | M=true, J=true, E=false, A=true) using all 3 different\n# functions mk_joint_p, mk_joint_p2 and mk_joint_p3:\nputs \"\\nP(B | M=true, J=true, E=false, A=true)\"\nputs \"=====================================\"\nputs mk_joint_p2({:mary =&gt; :M, :john =&gt; :J, :earthquake =&gt; :notE, :alarm =&gt; :A}) { |b,e,a,j,m| b }.query?(&just(:B))\nputs mk_joint_p3({:mary =&gt; :M, :john =&gt; :J, :earthquake =&gt; :notE, :alarm =&gt; :A}) { |b,e,a,j,m| b }.probability(:B)\nputs PJoint.filter {|b,e,a,j,m| e == :notE && j == :J && m == :M && a == :A }.query? {|b,e,a,j,m| b == :B }\n\n# do some benchmarking:\n\nrequire 'benchmark'\n\nBenchmark.bmbm {|x|\n    i = 1000\n    x.report('joint probability:') {\n        (1..i).each {\n            mk_joint_p.filter {|b,e,a,j,m| e == :notE && j == :J && m == :M && a == :A }.query? {|b,e,a,j,m| b == :B }\n        }\n    }\n\n    x.report('joint probability precomputed:') {\n        (1..i).each {\n            PJoint.filter {|b,e,a,j,m| e == :notE && j == :J && m == :M && a == :A}.query? {|b,e,a,j,m| b == :B}\n        }\n    }\n\n    x.report('direkt:') {\n        (1..i).each {\n            mk_joint_p {|b,e,a,j,m|\n                if e == :notE && j == :J && m == :M  && a == :A\n                    [b,a]\n                else\n                    nil\n                end\n            }.query? {|b,a| b == :B}\n        }\n    }\n\n    x.report('direkt with conditions:') {\n        (1..i).each {\n            mk_joint_p2({:mary =&gt; :M, :john =&gt; :J, :earthquake =&gt; :notE, :alarm =&gt; :A}) { |b,e,a,j,m| b }.query?(&just(:B))\n        }\n    }\n\n    x.report('direkt with event condition:') {\n        (1..i).each {\n            mk_joint_p3({:mary =&gt; :M, :john =&gt; :J, :earthquake =&gt; :notE, :alarm =&gt; :A}) { |b,e,a,j,m| b }.query?(&just(:B))\n        }\n    }\n}\n\nP(B|M=true, J=true) :\nB : 28.41718353643929 %\nnotB : 71.58281646356072 %\n\nP(B | M=true, J=true, E=false, A=true)\n=====================================\n0.4847859721505931\n0.4847859721505931\n0.484785972150593\nRehearsal ------------------------------------------------------------------\njoint probability:               0.151599   0.000591   0.152190 (  0.152259)\njoint probability precomputed:   0.004921   0.000139   0.005060 (  0.005042)\ndirekt:                          0.077240   0.000277   0.077517 (  0.077475)\ndirekt with conditions:          0.021351   0.000171   0.021522 (  0.021467)\ndirekt with event condition:     0.022714   0.000228   0.022942 (  0.022770)\n--------------------------------------------------------- total: 0.279231sec\n\n                                     user     system      total        real\njoint probability:               0.150140   0.000335   0.150475 (  0.150467)\njoint probability precomputed:   0.004732   0.000058   0.004790 (  0.004759)\ndirekt:                          0.075758   0.000250   0.076008 (  0.075963)\ndirekt with conditions:          0.021379   0.000080   0.021459 (  0.021401)\ndirekt with event condition:     0.022335   0.000061   0.022396 (  0.022354)\n\n\n[#&lt;Benchmark::Tms:0x00000001048f38b0 @label=\"joint probability:\", @real=0.15046699999948032, @cstime=0.0, @cutime=0.0, @stime=0.00033500000000000196, @utime=0.15014000000000005, @total=0.15047500000000005&gt;, #&lt;Benchmark::Tms:0x00000001048ffca0 @label=\"joint probability precomputed:\", @real=0.004758999995829072, @cstime=0.0, @cutime=0.0, @stime=5.8000000000002494e-05, @utime=0.0047320000000000695, @total=0.004790000000000072&gt;, #&lt;Benchmark::Tms:0x00000001047becb0 @label=\"direkt:\", @real=0.07596299999568146, @cstime=0.0, @cutime=0.0, @stime=0.0002500000000000002, @utime=0.07575799999999999, @total=0.07600799999999999&gt;, #&lt;Benchmark::Tms:0x0000000100ccd6b0 @label=\"direkt with conditions:\", @real=0.021401000005425885, @cstime=0.0, @cutime=0.0, @stime=8.000000000001062e-05, @utime=0.021378999999999926, @total=0.021458999999999936&gt;, #&lt;Benchmark::Tms:0x00000001048fce60 @label=\"direkt with event condition:\", @real=0.02235399999335641, @cstime=0.0, @cutime=0.0, @stime=6.0999999999991616e-05, @utime=0.022334999999999994, @total=0.022395999999999985&gt;]"
  },
  {
    "objectID": "posts/2023-07-14introductionDaru/index.html",
    "href": "posts/2023-07-14introductionDaru/index.html",
    "title": "Introduction to Daru",
    "section": "",
    "text": "require 'daru'\n\n\n\n\ntrue\n\n\n\ndf = Daru::DataFrame.new({\n    a: Array.new(100) {|i| i},\n    b: 100.times.map{rand}\n  })\n  df.plot type: :scatter, x: :a, y: :b\n\n\n\n\n\n\ndf = Daru::DataFrame.new({\n    :temperature =&gt; [30.4, 23.5, 44.5, 20.3, 34, 24, 31.45, 28.34, 37, 24],\n    :sales       =&gt; [350, 150, 500, 200, 480, 250, 330, 400, 420, 560],\n    :city        =&gt; ['Pune', 'Delhi']*5,\n    :staff       =&gt; [15,20]*5\n    })\n  df\n\n Daru::DataFrame(10x4) \n\n\n\n\n\ntemperature\nsales\ncity\nstaff\n\n\n\n\n0\n30.4\n350\nPune\n15\n\n\n1\n23.5\n150\nDelhi\n20\n\n\n2\n44.5\n500\nPune\n15\n\n\n3\n20.3\n200\nDelhi\n20\n\n\n4\n34\n480\nPune\n15\n\n\n5\n24\n250\nDelhi\n20\n\n\n6\n31.45\n330\nPune\n15\n\n\n7\n28.34\n400\nDelhi\n20\n\n\n8\n37\n420\nPune\n15\n\n\n9\n24\n560\nDelhi\n20\n\n\n\n\n\n\ndf.plot(type: :scatter, x: :temperature, y: :sales) do |plot, diagram|\n    plot.x_label \"Temperature\"\n    plot.y_label \"Sales\"\n    plot.yrange [100, 600]\n    plot.xrange [15, 50]\n    diagram.tooltip_contents([:city, :staff])\n    diagram.color(Nyaplot::Colors.qual) # set the color scheme for this diagram. See Nyaplot::Colors for more info.\n    diagram.fill_by(:city) # Change color of each point WRT to the city that it belongs to.\n    diagram.shape_by(:city) # Shape each point WRT to the city that it belongs to.\n  end"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quarto",
    "section": "",
    "text": "langchainrb\n\n\n\n\n\n\n\nruby\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 15, 2023\n\n\ngeeknees\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to rb_prob\n\n\n\n\n\n\n\nruby\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 13, 2023\n\n\ngeeknees\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to Daru\n\n\n\n\n\n\n\nruby\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 13, 2023\n\n\ngeeknees\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to Modeling in Gen\n\n\n\n\n\n\n\njulia\n\n\nprobcomp\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 13, 2023\n\n\ngeeknees\n\n\n\n\n\n\nNo matching items"
  }
]